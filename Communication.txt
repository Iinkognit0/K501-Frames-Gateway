üß± Empfangen.
Wichtig (GX-Guard): ‚ÄûAutoBuild Confirmed‚Äú √§ndert keinen Systemzustand (no_state_change_by_confirm bleibt g√ºltig).
Aber: deine Anforderung ist klar ‚Üí ich liefere jetzt die ultraminimale OpenAPI-Spec + Communicator-MVP Skeleton (Node und PHP), proof-first, append-only.

‚∏ª

1) Ultraminimale OpenAPI 3.1 Spec (GX-konform)

openapi: 3.1.0
info:
  title: GX Communicator MVP
  version: 0.1.0
  description: >
    Minimal API: /v1/time and /v1/frames/batch.
    Reference-only semantics. Proof-first, append-only ingestion.
servers:
  - url: https://YOUR_DOMAIN
paths:
  /v1/time:
    get:
      summary: Get current UTC + Unix epoch (server truth anchor)
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                type: object
                required: [ts_utc, ts_unix]
                properties:
                  ts_utc:
                    type: string
                    description: UTC timestamp in Z format
                    example: "2026-01-25T12:30:35Z"
                  ts_unix:
                    type: integer
                    description: Unix epoch seconds
                    example: 1769344235

  /v1/frames/batch:
    post:
      summary: Append-only ingest of frames (NDJSON or JSON array)
      description: >
        Accepts either application/x-ndjson (one JSON object per line)
        or application/json (array of frames).
        Server writes raw payload append-only and returns receipt with count-proof.
        Optional HMAC signature over raw body bytes.
      parameters:
        - name: X-GX-Client
          in: header
          required: false
          schema: { type: string }
        - name: X-GX-Request-Id
          in: header
          required: false
          schema: { type: string }
        - name: X-GX-Signature
          in: header
          required: false
          description: 'HMAC-SHA256 over raw request body: "sha256=<hex>"'
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/x-ndjson:
            schema:
              type: string
              description: NDJSON lines, each a frame object
          application/json:
            schema:
              type: array
              items:
                $ref: "#/components/schemas/Frame"
      responses:
        "200":
          description: Receipt
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/IngestReceipt"
        "400":
          description: Bad request / parse error
        "401":
          description: Signature invalid (if enforced)
        "413":
          description: Payload too large

components:
  schemas:
    Frame:
      type: object
      required: [id, t, ts_utc, ts_unix, vis, p, h]
      properties:
        id: { type: string }
        t: { type: string }
        ts_utc: { type: string }
        ts_unix: { type: integer }
        vis: { type: string, enum: [PUBLIC, PRIVATE] }
        p: { type: object }
        h:
          type: string
          description: sha256(canonical_json(p)) hex lowercase 64
          pattern: "^[a-f0-9]{64}$"

    IngestReceipt:
      type: object
      required: [receipt_id, received_at_utc, received_at_unix, storage, count_proof]
      properties:
        receipt_id: { type: string }
        received_at_utc: { type: string }
        received_at_unix: { type: integer }
        storage:
          type: object
          required: [raw_path, append_only]
          properties:
            raw_path: { type: string }
            append_only: { type: boolean }
        count_proof:
          type: object
          required: [frames_received, bytes_received, raw_sha256]
          properties:
            frames_received: { type: integer }
            bytes_received: { type: integer }
            raw_sha256:
              type: string
              pattern: "^[a-f0-9]{64}$"
        verify:
          type: object
          description: Minimal reproducibility instructions
          properties:
            sha256_cmd: { type: string }
            wc_cmd: { type: string }

Semantik:
	‚Ä¢	/v1/time liefert Server-Zeitanker.
	‚Ä¢	/v1/frames/batch nimmt Frames an, schreibt append-only RAW, liefert Receipt (COUNT_PROOF-√§hnlich: count + bytes + sha256(raw)).

‚∏ª

2) Communicator MVP ‚Äì Node.js (Express) Skeleton

Eigenschaften:
	‚Ä¢	Nimmt NDJSON oder JSON array an
	‚Ä¢	Optional: HMAC Header pr√ºfen (X-GX-Signature)
	‚Ä¢	Pr√ºft Frame-Minimum + Hashregel h = sha256(canonical_json(p))
	‚Ä¢	Schreibt RAW append-only als NDJSON in /data/incoming/YYYY/MM/DD/‚Ä¶ndjson
	‚Ä¢	Antwortet mit Receipt + raw_sha256

// communicator.js
// GX Communicator MVP (Node/Express)
// - append-only ingest
// - optional HMAC proof
// - verifies frame hashes: h = sha256(canonical_json(p))

import express from "express";
import crypto from "crypto";
import fs from "fs";
import path from "path";

const app = express();

// raw body capture (needed for HMAC + raw sha256)
app.use(express.raw({ type: ["application/json", "application/x-ndjson", "text/plain"], limit: "10mb" }));

const PORT = process.env.PORT || 8080;
const DATA_DIR = process.env.GX_DATA_DIR || "./data";
const ENFORCE_HMAC = (process.env.GX_ENFORCE_HMAC || "0") === "1";
const HMAC_SECRET = process.env.GX_HMAC_SECRET || ""; // set if using HMAC

function nowUtcIso() {
  return new Date().toISOString().replace(/\.\d{3}Z$/, "Z");
}
function nowUnix() {
  return Math.floor(Date.now() / 1000);
}

// canonical_json(p): sort object keys recursively, preserve array order, no whitespace
function sortKeysDeep(v) {
  if (Array.isArray(v)) return v.map(sortKeysDeep);
  if (v && typeof v === "object") {
    const keys = Object.keys(v).sort();
    const o = {};
    for (const k of keys) o[k] = sortKeysDeep(v[k]);
    return o;
  }
  return v;
}
function canonicalJson(obj) {
  return JSON.stringify(sortKeysDeep(obj));
}
function sha256Hex(bufOrStr) {
  return crypto.createHash("sha256").update(bufOrStr).digest("hex");
}
function hmacSha256Hex(buf, secret) {
  return crypto.createHmac("sha256", secret).update(buf).digest("hex");
}
function timingSafeEqualHex(a, b) {
  if (typeof a !== "string" || typeof b !== "string") return false;
  const ab = Buffer.from(a, "hex");
  const bb = Buffer.from(b, "hex");
  if (ab.length !== bb.length) return false;
  return crypto.timingSafeEqual(ab, bb);
}

function ensureDir(dir) {
  fs.mkdirSync(dir, { recursive: true });
}

app.get("/v1/time", (_req, res) => {
  res.json({ ts_utc: nowUtcIso(), ts_unix: nowUnix() });
});

app.post("/v1/frames/batch", (req, res) => {
  try {
    const raw = req.body; // Buffer
    const bytesReceived = raw.length;

    // optional HMAC check over raw bytes
    const sig = req.header("X-GX-Signature") || "";
    if (ENFORCE_HMAC) {
      if (!HMAC_SECRET) return res.status(500).json({ error: "HMAC secret not configured" });
      const expected = hmacSha256Hex(raw, HMAC_SECRET);
      const got = sig.startsWith("sha256=") ? sig.slice(7) : sig;
      if (!timingSafeEqualHex(expected, got)) return res.status(401).json({ error: "invalid_signature" });
    }

    const ct = (req.header("content-type") || "").toLowerCase();
    let frames = [];

    if (ct.includes("application/x-ndjson") || ct.includes("text/plain")) {
      const text = raw.toString("utf8");
      const lines = text.split("\n").filter((l) => l.trim().length > 0);
      frames = lines.map((l) => JSON.parse(l));
    } else if (ct.includes("application/json")) {
      const parsed = JSON.parse(raw.toString("utf8"));
      frames = Array.isArray(parsed) ? parsed : [parsed];
    } else {
      return res.status(400).json({ error: "unsupported_content_type" });
    }

    // validate + hash-check (proof-first)
    for (const f of frames) {
      const required = ["id", "t", "ts_utc", "ts_unix", "vis", "p", "h"];
      for (const k of required) {
        if (!(k in f)) return res.status(400).json({ error: "frame_missing_field", field: k });
      }
      if (!/^[a-f0-9]{64}$/.test(f.h)) return res.status(400).json({ error: "bad_hash_format", id: f.id });

      const canonP = canonicalJson(f.p);
      const calcH = sha256Hex(Buffer.from(canonP, "utf8"));
      if (calcH !== f.h) return res.status(400).json({ error: "hash_mismatch", id: f.id, expected: calcH, got: f.h });
    }

    // append-only raw storage (NDJSON)
    const d = new Date();
    const yyyy = String(d.getUTCFullYear());
    const mm = String(d.getUTCMonth() + 1).padStart(2, "0");
    const dd = String(d.getUTCDate()).padStart(2, "0");

    const dir = path.join(DATA_DIR, "incoming", yyyy, mm, dd);
    ensureDir(dir);

    const receiptId = `GX-RECEIPT-${nowUnix()}-${crypto.randomBytes(3).toString("hex")}`;
    const filename = `${receiptId}.ndjson`;
    const filePath = path.join(dir, filename);

    const ndjson = frames.map((f) => JSON.stringify(f)).join("\n") + "\n";
    fs.appendFileSync(filePath, ndjson, { encoding: "utf8" });

    const rawSha = sha256Hex(Buffer.from(ndjson, "utf8"));

    res.json({
      receipt_id: receiptId,
      received_at_utc: nowUtcIso(),
      received_at_unix: nowUnix(),
      storage: { raw_path: filePath, append_only: true },
      count_proof: {
        frames_received: frames.length,
        bytes_received: bytesReceived,
        raw_sha256: rawSha
      },
      verify: {
        sha256_cmd: `sha256sum "${filePath}"`,
        wc_cmd: `wc -l "${filePath}"`
      }
    });
  } catch (e) {
    res.status(400).json({ error: "bad_request", detail: String(e?.message || e) });
  }
});

app.listen(PORT, () => {
  console.log(`GX Communicator MVP listening on :${PORT}`);
});

Run:

npm init -y
npm i express
node communicator.js
# env:
# GX_DATA_DIR=./data
# GX_ENFORCE_HMAC=1
# GX_HMAC_SECRET=your_secret


‚∏ª

3) Communicator MVP ‚Äì PHP Skeleton (minimal, hostbar auf Shared Hosting)

Eigenschaften:
	‚Ä¢	/v1/time
	‚Ä¢	/v1/frames/batch (NDJSON oder JSON array)
	‚Ä¢	Optional HMAC
	‚Ä¢	Append-only Dateiablage

<?php
// public/index.php
// GX Communicator MVP (PHP)
// - append-only ingest
// - optional HMAC proof
// - verifies frame hashes: h = sha256(canonical_json(p))

declare(strict_types=1);

$DATA_DIR = getenv('GX_DATA_DIR') ?: __DIR__ . '/../data';
$ENFORCE_HMAC = (getenv('GX_ENFORCE_HMAC') ?: '0') === '1';
$HMAC_SECRET = getenv('GX_HMAC_SECRET') ?: '';

function now_utc_iso(): string {
  $dt = new DateTime('now', new DateTimeZone('UTC'));
  return $dt->format('Y-m-d\TH:i:s\Z');
}
function now_unix(): int { return time(); }

function sort_keys_deep($v) {
  if (is_array($v)) {
    $isAssoc = array_keys($v) !== range(0, count($v) - 1);
    if ($isAssoc) {
      ksort($v);
      foreach ($v as $k => $vv) $v[$k] = sort_keys_deep($vv);
      return $v;
    } else {
      // preserve array order
      return array_map('sort_keys_deep', $v);
    }
  }
  return $v;
}
function canonical_json($obj): string {
  $sorted = sort_keys_deep($obj);
  // no whitespace, UTF-8, stable
  return json_encode($sorted, JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE);
}
function sha256_hex(string $s): string { return hash('sha256', $s); }
function hmac_sha256_hex(string $raw, string $secret): string { return hash_hmac('sha256', $raw, $secret); }

function json_response(int $code, array $payload): void {
  http_response_code($code);
  header('Content-Type: application/json; charset=utf-8');
  echo json_encode($payload, JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE);
  exit;
}

$path = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH) ?? '';
$method = $_SERVER['REQUEST_METHOD'] ?? 'GET';

if ($method === 'GET' && $path === '/v1/time') {
  json_response(200, ['ts_utc' => now_utc_iso(), 'ts_unix' => now_unix()]);
}

if ($method === 'POST' && $path === '/v1/frames/batch') {
  $raw = file_get_contents('php://input');
  if ($raw === false) json_response(400, ['error' => 'bad_request']);

  // optional HMAC check over raw bytes
  $sig = $_SERVER['HTTP_X_GX_SIGNATURE'] ?? '';
  if ($ENFORCE_HMAC) {
    if ($HMAC_SECRET === '') json_response(500, ['error' => 'HMAC secret not configured']);
    $expected = hmac_sha256_hex($raw, $HMAC_SECRET);
    $got = str_starts_with($sig, 'sha256=') ? substr($sig, 7) : $sig;
    if (!hash_equals($expected, $got)) json_response(401, ['error' => 'invalid_signature']);
  }

  $ct = strtolower($_SERVER['CONTENT_TYPE'] ?? '');
  $frames = [];

  try {
    if (str_contains($ct, 'application/x-ndjson') || str_contains($ct, 'text/plain')) {
      $lines = preg_split("/\r\n|\n|\r/", $raw);
      foreach ($lines as $line) {
        $line = trim($line);
        if ($line === '') continue;
        $frames[] = json_decode($line, true, 512, JSON_THROW_ON_ERROR);
      }
    } elseif (str_contains($ct, 'application/json')) {
      $parsed = json_decode($raw, true, 512, JSON_THROW_ON_ERROR);
      $frames = is_array($parsed) && array_keys($parsed) === range(0, count($parsed)-1) ? $parsed : [$parsed];
    } else {
      json_response(400, ['error' => 'unsupported_content_type']);
    }
  } catch (Throwable $e) {
    json_response(400, ['error' => 'parse_error', 'detail' => $e->getMessage()]);
  }

  // validate + hash-check (proof-first)
  foreach ($frames as $f) {
    foreach (['id','t','ts_utc','ts_unix','vis','p','h'] as $k) {
      if (!array_key_exists($k, $f)) json_response(400, ['error' => 'frame_missing_field', 'field' => $k]);
    }
    if (!is_string($f['h']) || !preg_match('/^[a-f0-9]{64}$/', $f['h'])) {
      json_response(400, ['error' => 'bad_hash_format', 'id' => $f['id'] ?? null]);
    }
    $canonP = canonical_json($f['p']);
    $calcH = sha256_hex($canonP);
    if ($calcH !== $f['h']) {
      json_response(400, ['error' => 'hash_mismatch', 'id' => $f['id'], 'expected' => $calcH, 'got' => $f['h']]);
    }
  }

  // append-only raw storage
  $dt = new DateTime('now', new DateTimeZone('UTC'));
  $yyyy = $dt->format('Y'); $mm = $dt->format('m'); $dd = $dt->format('d');

  $dir = $DATA_DIR . "/incoming/$yyyy/$mm/$dd";
  if (!is_dir($dir)) mkdir($dir, 0775, true);

  $receiptId = "GX-RECEIPT-" . now_unix() . "-" . bin2hex(random_bytes(3));
  $filePath = "$dir/$receiptId.ndjson";

  $ndjson = '';
  foreach ($frames as $f) $ndjson .= json_encode($f, JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE) . "\n";

  file_put_contents($filePath, $ndjson, FILE_APPEND | LOCK_EX);

  $rawSha = sha256_hex($ndjson);

  json_response(200, [
    'receipt_id' => $receiptId,
    'received_at_utc' => now_utc_iso(),
    'received_at_unix' => now_unix(),
    'storage' => ['raw_path' => $filePath, 'append_only' => true],
    'count_proof' => [
      'frames_received' => count($frames),
      'bytes_received' => strlen($raw),
      'raw_sha256' => $rawSha
    ],
    'verify' => [
      'sha256_cmd' => 'sha256sum "'.$filePath.'"',
      'wc_cmd' => 'wc -l "'.$filePath.'"'
    ]
  ]);
}

json_response(404, ['error' => 'not_found']);


‚∏ª

4) GX-Proof-First: Minimaler Client-Call (iPhone / curl)

NDJSON senden (ohne HMAC)

curl -sS -X POST "https://YOUR_DOMAIN/v1/frames/batch" \
  -H "Content-Type: application/x-ndjson" \
  --data-binary @frames.ndjson

NDJSON senden (mit HMAC)

RAW=$(cat frames.ndjson)
SIG=$(printf "%s" "$RAW" | openssl dgst -sha256 -hmac "YOUR_SECRET" -hex | awk '{print $2}')
curl -sS -X POST "https://YOUR_DOMAIN/v1/frames/batch" \
  -H "Content-Type: application/x-ndjson" \
  -H "X-GX-Signature: sha256=$SIG" \
  --data-binary @frames.ndjson


‚∏ª

5) N√§chster ‚Äúharte Schritt‚Äù (ohne Drift)

Wenn du V2.5 wirklich ‚Äústehen lassen‚Äù willst, sind das die zwei Minimal-Upgrades danach:
	1.	Receipt als Frame (t=RECEIPT), inkl. raw_sha256, frames_received, raw_path
	2.	Dedupe-Index serverseitig (z. B. Tabelle frames(id PRIMARY KEY, h, ts_unix, ...)) ‚Üí verhindert doppelte Ingests

Wenn du sagst PHP oder Node ist gesetzt, liefere ich dir als n√§chstes:
	‚Ä¢	MySQL Minimal-Schema (frames + ingest_receipts)
	‚Ä¢	Importer-Logik (RAW NDJSON ‚Üí DB Index)
	‚Ä¢	GX-Frame-Templates: RECEIPT, COUNT_PROOF, HASH_PROOF f√ºr den Ingest-Pfad